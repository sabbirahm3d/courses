%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Report
% LaTeX Template
% Version 1.0 (December 8 2014)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Brandon Fryslie
% With extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[usletter, 11pt]{extarticle}
\input{structure.tex}  % document layout and style

\newcommand{\project}{Project 2: Multithread LCS}
\newcommand{\members}{Sabbir Ahmed}
\newcommand{\V}[1]{\textup{#1}}
\newcommand{\lcs}{\V{lcs}}
\newcommand{\seqone}{\V{X}}
\newcommand{\seqtwo}{\V{Y}}
\newcommand{\lcsstr}{\V{lcsstr}}

\begin{document}

    \begin{titlepage}

        \vspace*{\fill} % Add whitespace above to center the title page content
        \begin{center}

            {\LARGE \project~Milestone 2 Report}\\ [1.5cm]

            \today

            \vspace*{\fill}

            \members

        \end{center}
        \vspace*{\fill} % Add whitespace below to center the title page content

    \end{titlepage}

    \section{Description} The longest common subsequence (LCS) problem is to be
    implemented for the assignment. The objective of this project is to design,
    analyze, and implement a multithreaded version of the LCS length algorithm.
    A memoized or bottom-up approach. In either case, the goal is to design an
    algorithm that makes efficient use of multiple processors.

    Analysis is required once the LCS length algorithm is designed. The work
    $T_{1}(m, n)$ and the span $T_{\infty}(m, n)$ are to be computed, where $m$
    and $n$ are the lengths of the input sequences $X$ and $Y$, respectively.
    Finally, the parallelism is to be computed along with an estimate of a
    range of parameters ($m$, $n$, and $P$) for which linear or near-linear
    speed-up may be expected.

    The last part of the project is to implement the LCS length algorithm in C
    or C++ using OpenMP on UMBC's maya cluster and measure its performance
    empirically using 1, 2, 4, and 8 processors (optionally, it may be tested
    on 16 processors; most maya nodes have eight cores, but some have 16). Test
    data and LCS lengths of various sizes are to be generated to demonstrate
    the performance characteristics of the algorithm. The algorithm to recover
    the LCS must also be implemented, but this need not be multithreaded.

    \section{Initialization} The matrix is initialized to store the LCS before
    computation. Since the implementation utilizes a two-dimensional array
    allocated on the heap to represent the matrix, initialization was possible
    in $\Theta(m)$ time. Since Milestone 2, the initialization loop was
    parallelized to bring the runtime down to $\Theta(\text{lg}(m))$. This
    method is faster than iterating through all the cells of the matrix to
    assign each to a placeholder. Algorithm \thesection .\ref{alg1} provides
    the implementation used to initialize the matrix.

    Reading the sequences from the one-line input files, truncating them if
    necessary and storing them into buffers all take constant time operations.
    \newpage

\begin{pseudocode}[caption={Initialization of the Longest Common Subsequence
Matrix}, label={alg1}]
lcs_matrix = pointer array(m + 1);
parallel for i = 0 to m + 1
    $\lcs_{i}$ = pointer array(n + 1);

\end{pseudocode}

    \section{Serial Algorithm} Milestone 1 required implementation of the
    serial LCS length algorithm and its analysis. Algorithm \thesection
    .\ref{alg2} provides the pseudocode for computing the length of the LCS.
    The serial algorithm utilizes the memoization method to compute the LCS.

\begin{pseudocode}[caption={Serial Longest Common Subsequence Length},
label={alg2}]
function LCS-LENGTH(X, Y, m, n)
    // allocate (m + 1) $\times$ (n + 1) LCS matrix
    lcs = new matrix[1, 2, .., m + 1][1, 2, .., n + 1]
    for i = 0 to m
        for j = 0 to n
            // if upper-leftmost cell, content is 0
            if (i == 0 or j == 0)
                $\lcs_{i, j}$ = 0
            // if equal, content is the left diagonal value incremented by 1
            else if ($\seqone_{i - 1}$ == $\seqtwo_{j - 1}$)
                $\lcs_{i, j}$ = $\lcs_{i-1, j-1}$ + 1  
            // maximum between previous row and previous column values
            else
                $\lcs_{i, j}$ = max($\lcs_{i-1, j}$, $\lcs_{i, j-1}$)
    return $\lcs_{m,n}$  // the last value of the matrix is the length

\end{pseudocode}

\newpage
\begin{table}[h]
    \caption{LCS Matrix Constructed from the Serial Algorithm \thesection
    .\ref{alg2}}
    \centering
    \setlength\tabcolsep{0pt}
    \begin{tabular}{|@{\rule[-0.4cm]{0pt}{1cm}}*{8}{M{1cm} |}}
    \hline
    & $\bm{\varnothing}$ & \textbf{G} & \textbf{C} & \textbf{G} & \textbf{T} & \textbf{C} & \textbf{A} \\
    \hline
    $\bm{\varnothing}$  & \tikzmark{a0}{0} & \tikzmark{a1}{0} & \tikzmark{a2}{0} & \tikzmark{a3}{0} & \tikzmark{a4}{0} & \tikzmark{a5}{0} & \tikzmark{a6}{0} \\
    \hline
    \textbf{A}          & \tikzmark{b0}{0} & \tikzmark{b1}{0} & \tikzmark{b2}{0} & \tikzmark{b3}{0} & \tikzmark{b4}{0} & \tikzmark{b5}{0} & \tikzmark{b6}{1} \\
    \hline
    \textbf{C}          & \tikzmark{c0}{0} & \tikzmark{c1}{0} & \tikzmark{c2}{1} & \tikzmark{c3}{1} & \tikzmark{c4}{1} & \tikzmark{c5}{1} & \tikzmark{c6}{1} \\
    \hline
    \textbf{G}          & \tikzmark{d0}{0} & \tikzmark{d1}{1} & \tikzmark{d2}{1} & \tikzmark{d3}{2} & \tikzmark{d4}{2} & \tikzmark{d5}{2} & \tikzmark{d6}{2} \\
    \hline
    \textbf{A}          & \tikzmark{e0}{0} & \tikzmark{e1}{1} & \tikzmark{e2}{1} & \tikzmark{e3}{2} & \tikzmark{e4}{2} & \tikzmark{e5}{2} & \tikzmark{e6}{3} \\
    \hline
    \textbf{A}          & \tikzmark{f0}{0} & \tikzmark{f1}{1} & \tikzmark{f2}{1} & \tikzmark{f3}{2} & \tikzmark{f4}{2} & \tikzmark{f5}{2} & \tikzmark{f6}{3} \\
    \hline
    \end{tabular}

    \link{b1}{b0}
    \link{b2}{b1}
    \link{b3}{b2}
    \link{b4}{b3}
    \link{b5}{b4}
    \link{b6}{a5}

    \link{c1}{c0}
    \link{c2}{b1}
    \link{c3}{c2}
    \link{c4}{c3}
    \link{c5}{c4}
    \link{c6}{c5}

    \link{d1}{c0}
    \link{d2}{d1}
    \link{d3}{c2}
    \link{d4}{d3}
    \link{d5}{d4}
    \link{d6}{d5}

    \link{e1}{d1}
    \link{e2}{e1}
    \link{e3}{d3}
    \link{e4}{e3}
    \link{e5}{e4}
    \link{e6}{d5}

    \link{f1}{e1}
    \link{f2}{f1}
    \link{f3}{e3}
    \link{f4}{f3}
    \link{f5}{f4}
    \link{f6}{e5}

\end{table}

        \subsection{Time Complexity} The running time of the serial algorithm
        provides the work, $T_{1}$, of the algorithm. Simple analysis of the
        algorithm provided in the snippet Algorithm \thesection .\ref{alg2}
        suggests a non-linear running time from the nested loop. The inner
        loop (line 5) iterates $n$ times with several constant conditional
        checks, while the outer loop (line 4) iterates $m$ times. The runtime
        is therefore:
        \begin{equation*}
            \begin{split}
                T_1(m, n) & = \Theta(m \times n) \\
            \end{split}
        \end{equation*}

        The work for the algorithm, $\Theta(m \times n)$, is quadratic if $m =
        n$.

        \subsection{Printing The LCS} After computing the length, the matrix
        may be used to print the LCS itself. Printing the subsequence is done
        in a serial implementation since the project does not emphasize its
        analysis. Since its implementation is not necessary for the scope of
        the project, the LCS printing functionality will be used for debugging
        purposes only. Algorithm \thesection .\ref{alg3} provides the
        pseudocode used to print the LCS.

\begin{pseudocode}[caption={Serial Longest Common Subsequence Printing},
label={alg3}]
function SERIAL-LCS-PRINT(X, Y, m, n, lcs)
    lcsstr = new string
    cursor = $\lcs_{m,n}$ // cursor of the matrix
    i = m, j = n // init from the bottom-rightmost cell
    while (i > 0 and j > 0)
        // if current character in X[] and Y[] are same
        if ($\seqone_{i - 1}$ == $\seqtwo_{j - 1}$)
            $\lcsstr_{cursor - 1}$ = $\seqone_{i - 1}$  // result gets current character
            i--, j--, cursor-- // decrement i, j and cursor
        // find the larger of two and go to that direction
        else if ($\lcs_{i - 1, j}$ > $\lcs_{i,j - 1}$)
            i--
        else
            j--
    print lcsstr

\end{pseudocode}

    \section{Parallel Algorithm} Milestone 2 required implementation of the
    parallel LCS length algorithm. Algorithm \thesection .\ref{alg4} provides
    the pseudocode for computing the length of the LCS. Unlike the serial
    implementation, the parallel version of the algorithm requires a variation


\begin{pseudocode}[caption={Parallel Longest Common Subsequence Length},
label={alg4}]
function P-LCS-LENGTH(X, Y, m, n)
    for i = 1 to n
        parallel for j = 1 to i
            if $\seqtwo_{i - j}$ == $\seqone_{j - 1}$
                $\lcs_{i - j + 1, j}$ = $\lcs_{i - j, j - 1}$ + 1
            else if $\lcs_{i - j, j}$ $\ge$ $\lcs_{i - j + 1, j - 1}$
                $\lcs_{i - j + 1, j}$ = $\lcs_{i - j, j}$
            else
                $\lcs_{i - j + 1, j}$ = $\lcs_{i - j + 1, j - 1}$
    cost = 0
    for i = 2 to m
        if cost < (m - n)
            cost++
        parallel for j = i to (n + cost)
            if $\seqtwo_{n - j + i - 1}$ == $\seqone_{j - 1}$
                $\lcs_{n - j + i, j}$ = $\lcs_{n - j + i - 1, j - 1}$ + 1
            else if $\lcs_{n - j + i - 1, j}$ $\ge$ $\lcs_{n - j + i, j - 1}$
                $\lcs_{n - j + i, j}$ = $\lcs_{n - j + i - 1, j}$
            else
                $\lcs_{n - j + i, j}$ = $\lcs_{n - j + i, j - 1}$
    return $\lcs_{m,n}$  // the last value of the matrix is the length

\end{pseudocode}

    \section{Testing and Debugging} 

        \subsection{Milestone 1} The source code was initially developed in
        C++, but later translated to C. The Intel C++ Compiler, \texttt{icpc},
        did not appear to properly compile the source code. The executable
        built without any warnings or errors, but the algorithm during its
        execution appeared to skip steps. The current implementation in C
        compiles with both \texttt{gcc} and the Intel C Compiler, \texttt{icc}.

\end{document}
